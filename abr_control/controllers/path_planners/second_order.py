""" Implement a trajectory controller on top of a controller

Implements a second order filter for path generation.
Returns a set of target positions and velocities.
Implements the second order filter from
www.mathworks.com/help/physmod/sps/powersys/ref/secondorderfilter.html

returns target in form [positions, velocities]

***NOTE*** there are three ways to use this filter
1: wrt to timesteps (step at a time)
- each step (from 0 to n_timesteps) of the path planner is generated by the step
function.

2: wrt to timesteps (pregenerated)
- the step() function can be called in a loop, to pregenerate the path, by
calling the generate_path() function. Then each step can be passed sequentially
by calling the next_target() function in a loop

3: wrt to time
- after instantiation, calling `generate_path_function()` interpolates the path
to the specified time limit. Calling the `next_timestep(t)` function at a
specified time will return the end-effector state at that point along the path
planner. This ensures that the path will reach the desired target within the
time_limit specified in `generate_path_function()`


Parameters
----------
n_timesteps: int, optional (Default: 3000 ~3sec given a 3ms comm. loop)
    the number of time steps to reach the target
dt: float, optional (Default: 0.001)
    the loop speed [seconds]
zeta: float, optional (Default: 2.0)
    the damping ratio
w: float, optional (Default: 1e-4)
    the natural frequency
threshold: float, optional (Default: 0.02)
    within this threshold distance to target position reduce the
    filtering effects to improve convergence in practice
"""


import numpy as np

import scipy.interpolate

class SecondOrder:
    def __init__(self, n_timesteps=3000, dt=0.001,
                 zeta=2.0, w=1e4, threshold=0.02):

        self.n_timesteps = n_timesteps
        self.dt = dt
        self.zeta = zeta
        self.w = w/n_timesteps # gain to converge in the desired time
        self.threshold = threshold


    def generate_path(self, position, velocity, target_pos, plot=False):
        """
        Calls the step function self.n_timestep times to pregenerate
        the entire path planner

        Parameters
        ----------
        position: numpy.array
            the current position of the system
        velocity: numpy.array
            the current velocity of the system
        target_pos: numpy.array
            the target position
        plot: boolean, optional (Default: False)
            plot the path after generating if True
        """

        n_states = len(position)

        position_path = []
        velocity_path = []
        for _ in range(self.n_timesteps):
            position_path.append(position)
            velocity_path.append(velocity)
            position, velocity = self.step(
                position, velocity, target_pos, dt=self.dt)
        self.position = np.array(position_path)
        self.velocity = np.array(velocity_path)

        # reset trajectory index
        self.n = 0

        if plot:
            import matplotlib.pyplot as plt
            plt.figure()
            plt.subplot(2, 1, 1)
            plt.plot(np.ones((self.n_timesteps, n_states)) *
                     np.arange(self.n_timesteps)[:, None],
                     self.position)
            plt.gca().set_prop_cycle(None)
            plt.plot(
                np.ones((self.n_timesteps, n_states))
                * np.arange(self.n_timesteps)[:, None],
                np.ones((self.n_timesteps, n_states)) * target_pos,
                '--')
            plt.legend(['%i' % ii for ii in range(n_states)] +
                       ['%i_target' % ii for ii in range(n_states)])
            plt.title('Trajectory positions')

            plt.subplot(2, 1, 2)
            plt.plot(np.ones((self.n_timesteps, n_states)) *
                     np.arange(self.n_timesteps)[:, None],
                     self.velocity)
            plt.legend(['d%i' % ii for ii in range(n_states)])
            plt.title('Trajectory velocities')
            plt.tight_layout()

            plt.show()


    def step(self, position, velocity, target_pos, dt=0.001):
        """ Calculates the next state given the current state and
        system dynamics' parameters.

        Parameters
        ----------
        position: numpy.array
            the current position of the system
        velocity: numpy.array
            the current velocity of the system
        target_pos: numpy.array
            the target position of the system
        dt: float
            the time step to move forward
        """

        w = self.w
        if np.linalg.norm(position - target_pos) < self.threshold:
            # if within a threshold distance, reduce the filter effect
            # NOTE: this is a ad-hoc method of improving performance at
            # short distances
            w *= 3

        accel = (w**2 * target_pos
                 - velocity * self.zeta * w
                 - position * w**2)
        velocity = velocity + accel * dt
        position = position + velocity * dt
        return position, velocity


    def next_target(self):
        """ Return the next target point along the generated trajectory """

        # get the next target state if we're not at the end of the trajectory
        position = None
        velocity = None
        position = (
            self.position[self.n] if self.n < self.n_timesteps else position)
        velocity = (
            self.velocity[self.n] if self.n < self.n_timesteps else velocity)
        self.n += 1

        return position, velocity


    def generate_path_function(self, position, velocity,
                               target_pos, time_limit):
        """
        Generates a path function from current state to target and
        interpolates with respect to the time_limit. The function can
        then be stepped through to reach a target within the specified time.

        PARAMETERS
        ----------
        position: numpy.array
            the current position of the system
        velocity: numpy.array
            the current velocity of the system
        target_post of 3 floats
            the target end-effector position in cartesian coordinates [meters]
        time_limit: float
            the desired time to go from state to target [seconds]
        """

        n_states = len(position)
        self.generate_path(position, velocity, target_pos)
        dist = np.sqrt(np.sum((target_pos - self.position[-1])**2))

        while dist > 0.001:
            self.n_timesteps += 10
            self.generate_path(position, velocity, target_pos)
            dist = np.sqrt(np.sum((target_pos - self.position[-1])**2))

        times = np.linspace(0, time_limit, self.n_timesteps)
        self.position_path = []
        self.velocity_path = []
        for dim in range(n_states):
            self.position_path.append(scipy.interpolate.interp1d(
                times, self.position[:, dim]))
            #TODO: why do we get better performance with the gradient?
            # velocity_path.append(scipy.interpolate.interp1d(
            #     times, self.velocity[:, dim]))
            self.velocity_path.append(scipy.interpolate.interp1d(
                times, np.gradient(self.position[:, dim])))


    def next_timestep(self, t):
        """
        Called after `generate_path_function()` has been run to create the path
        planner function. The interpolated function is called and the path at
        time t is returned

        PARAMETERS
        ----------
        t: float
            time in seconds along the planned path
            ex: if generate_path_function is called with a 10 second limit,
            passing 5 in to next_timestep will return the position of the EE
            half-way (wrt time) through the generated path
        """
        position = []
        velocity = []

        for interp_function in self.position_path:
            position.append(np.copy(interp_function(t)))
        for interp_function in self.velocity_path:
            velocity.append(np.copy(interp_function(t)))

        return position, velocity
