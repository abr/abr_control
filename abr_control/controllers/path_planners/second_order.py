""" Implement a trajectory controller on top of a controller

Implements a second order filter for path generation.
Returns a set of target positions and velocities.
Implements the second order filter from
www.mathworks.com/help/physmod/sps/powersys/ref/secondorderfilter.html

returns target in form [positions, velocities]

***NOTE*** there are three ways to use this filter
1: wrt to timesteps (step at a time)
- each step (from 0 to n_timesteps) of the path planner is generated by the step
function.

2: wrt to timesteps (pregenerated)
- the step() function can be called in a loop, to pregenerate the path, by
calling the generate_path() function. Then each step can be passed sequentially
by calling the next_target() function in a loop

3: wrt to time
- after instantiation, calling `generate_path_function()` interpolates the path
to the specified time limit. Calling the `next_timestep(t)` function at a
specified time will return the end-effector state at that point along the path
planner. This ensures that the path will reach the desired target within the
time_limit specified in `generate_path_function()`


Parameters
----------
n_timesteps: int, optional (Default: 3000 ~3sec given a 3ms comm. loop)
    the number of time steps to reach the target
dt: float, optional (Default: 0.001)
    the loop speed [seconds]
zeta: float, optional (Default: 2.0)
    the damping ratio
w: float, optional (Default: 1e-4)
    the natural frequency
threshold: float, optional (Default: 0.02)
    within this threshold distance to target position reduce the
    filtering effects to improve convergence in practice
"""


import numpy as np

import scipy.interpolate

class SecondOrder:
    def __init__(self, n_timesteps=3000, dt=0.001,
                 zeta=2.0, w=1e4, threshold=0.02):

        self.n_timesteps = n_timesteps
        self.dt = dt
        self.zeta = zeta
        self.w = w/n_timesteps # gain to converge in the desired time
        self.threshold = threshold


    def generate_path(self, pos, vel, target_pos, plot=False):
        """
        Calls the step function self.n_timestep times to pregenerate the entire
        path planner

        Parameters
        ----------
        pos : numpy.array
            the current position of the system
        vel : numpy.array
            the current velocity of the system
        target_pos : numpy.array
            the target position
        plot: boolean, optional (Default: False)
            plot the path after generating if True
        """

        n_states = len(pos)

        pos_path = []
        vel_path = []
        for _ in range(self.n_timesteps):
            pos_path.append(pos)
            vel_path.append(vel)
            pos, vel = self.step(pos, vel, target_pos, dt=self.dt)
        self.pos = np.array(pos_path)
        self.vel = np.array(vel_path)

        # reset trajectory index
        self.n = 0

        if plot:
            import matplotlib.pyplot as plt
            plt.figure()
            plt.subplot(2, 1, 1)
            plt.plot(np.ones((self.n_timesteps, n_states)) *
                     np.arange(self.n_timesteps)[:, None],
                     self.pos)
            plt.gca().set_prop_cycle(None)
            plt.plot(np.ones((self.n_timesteps, n_states)) *
                     np.arange(self.n_timesteps)[:, None],
                     np.ones((self.n_timesteps, n_states)) * target_pos, '--')
            plt.legend(['%i' % ii for ii in range(n_states)] +
                       ['%i_target' % ii for ii in range(n_states)])
            plt.title('Trajectory positions')

            plt.subplot(2, 1, 2)
            plt.plot(np.ones((self.n_timesteps, n_states)) *
                     np.arange(self.n_timesteps)[:, None],
                     self.vel)
            plt.legend(['d%i' % ii for ii in range(n_states)])
            plt.title('Trajectory velocities')
            plt.tight_layout()

            plt.show()


    def step(self, pos, vel, target_pos, dt=0.001):
        """ Calculates the next state given the current state and
        system dynamics' parameters.

        Parameters
        ----------
        pos : numpy.array
            the current position of the system
        vel : numpy.array
            the current velocity of the system
        target_pos : numpy.array
            the target position of the system
        dt : float
            the time step to move forward
        """

        w = self.w
        if np.linalg.norm(pos - target_pos) < self.threshold:
            # if within a threshold distance, reduce the filter effect
            # NOTE: this is a ad-hoc method of improving performance at
            # short distances
            w *= 3

        accel = w**2 * target_pos - vel * self.zeta * w - pos * w**2
        vel = vel + accel * dt
        pos = pos + vel * dt
        return pos, vel


    def next_target(self):
        """ Return the next target point along the generated trajectory """

        # get the next target state if we're not at the end of the trajectory
        pos = None
        vel = None
        pos = (self.pos[self.n]
               if self.n < self.n_timesteps else pos)
        vel = (self.vel[self.n]
               if self.n < self.n_timesteps else vel)
        self.n += 1

        return pos, vel


    def generate_path_function(self, pos, vel, target_pos, time_limit):
        """
        Generates a path function from current state to target and interpolates
        with respect to the time_limit. The function can then be stepped through
        to reach a target within the specified time.

        PARAMETERS
        ----------
        target_pos: list of 3 floats
            the target end-effector position in cartesian coordinates [meters]
        pos : numpy.array
            the current position of the system
        vel : numpy.array
            the current velocity of the system
        time_limit: float
            the desired time to go from state to target [seconds]
        """

        n_states = len(pos)
        self.generate_path(pos=pos, vel=vel, target_pos=target_pos)
        dist = np.sqrt(np.sum((target_pos - self.pos[-1])**2))

        while dist > 0.001:
            self.n_timesteps += 10
            self.generate_path(pos=pos, vel=vel, target_pos=target_pos)
            dist = np.sqrt(np.sum((target_pos - self.pos[-1])**2))

        times = np.linspace(0, time_limit, self.n_timesteps)
        self.pos_path = []
        self.vel_path = []
        for dim in range(n_states):
            self.pos_path.append(scipy.interpolate.interp1d(
                times, self.pos[:, dim]))
            #TODO: why do we get better performance with the gradient?
            # vel_path.append(scipy.interpolate.interp1d(
            #     times, self.vel[:, dim]))
            self.vel_path.append(scipy.interpolate.interp1d(
                times, np.gradient(self.pos[:, dim])))


    def next_timestep(self, t):
        """
        Called after `generate_path_function()` has been run to create the path
        planner function. The interpolated function is called and the path at
        time t is returned

        PARAMETERS
        ----------
        t: float
            time in seconds along the planned path
            ex: if generate_path_function is called with a 10 second limit,
            passing 5 in to next_timestep will return the position of the EE
            half-way (wrt time) through the generated path
        """
        pos = []
        vel = []

        for interp_function in self.pos_path:
            pos.append(np.copy(interp_function(t)))
        for interp_function in self.vel_path:
            vel.append(np.copy(interp_function(t)))

        return pos, vel
